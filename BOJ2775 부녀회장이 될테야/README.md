# [2775] 부녀회장이 될테야

## 분류
> 수학

## 코드
```java
import java.util.Scanner;

public class BOJ2775 {
	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		int T = sc.nextInt();

		for (int i = 0; i < T; i++) {
			int k = sc.nextInt();
			int n = sc.nextInt();
			int[] arr = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14 }; // 호수
			int res = 0;

			if (n == 1)
				res = arr[0];
			else {
				for (int j = 0; j < k; j++) {
					for (int l = 1; l < arr.length; l++) {
						arr[l] = arr[l - 1] + arr[l];
						res = arr[n - 1];
					}
				}
			}
			System.out.println(res);
		}
		sc.close();
	}
}

```

## 문제풀이

호수는 1호, 층은 0층, 배열은 0부터.. 헷갈리지 않게 잘 해야 한다. 호수인 n만 하나 더 많기 때문에 출력할 때 n-1값을 출력하면 되겠다.

5호까지 3층정도만 손으로 써보면 바로 규칙을 발견할 수 있다. 

| 3층    | 1명  | 5명  | 15명 | 35명 | 70명 |
| ------ | ---- | ---- | ---- | ---- | ---- |
| 2층    | 1명  | 4명  | 10명 | 20명 | 35명 |
| 1층    | 1명  | 3명  | 6명  | 10명 | 15명 |
| 0층    | 1명  | 2명  | 3명  | 4명  | 5명  |
| 호수-> | 1호  | 2호  | 3호  | 4호  | 5호  |

0층은 무조건 i호에 i명이기 때문에 미리 배열을 선언해두었다. 

1층의 2호는 1층의 1호 + 0층의 2호

2층의 3호는 2층의 2호 + 1층의 3호

이렇게 규칙이 보인다. 이중반복문으로 한층씩 모든 호수를 돌면서 각 층의 거주자 수를 초기화해주고 해당 호수를 출력해주면 된다. 반복문을 k번 돌기 때문에 2층을 구하는데 3층까지 계산될 거라는 걱정은 할 필요가 없게 된다.

res에 모두 저장해두고 반복문이 끝나기 전에 출력해주고 다음 테스트케이스를 실행하도록 한다.

